# ДОКУМЕНТ: БЭКЛОГ РАЗРАБОТКИ И ОШИБОК
## Программный комплекс "Project Manager"
### Исх. № БР-01/2024 от 12.12.2024

---

## 1. ОБЗОР БЭКЛОГА РАЗРАБОТКИ

### 1.1. Статистика разработки
- **Количество спринтов**: 3
- **Всего задач**: 48
- **Выполнено задач**: 48 (100%)
- **Средняя скорость команды**: 16 story points/спринт

### 1.2. Команда разработки
| Роль | Количество | Основные обязанности |
|------|------------|----------------------|
| Backend разработчик | 2 | Бизнес-логика, API, БД |
| Frontend разработчик | 1 | Tkinter интерфейс |
| DevOps инженер | 1 | Развертывание, CI/CD |
| Тестировщик | 1 | QA, автоматизация тестов |

---

## 2. ЭПИКИ РАЗРАБОТКИ

### EPIC-DEV-001: Архитектура и инфраструктура
**Статус**: ✅ ЗАВЕРШЕНО  
**Сложность**: 15 story points

**Задачи**:
- [x] **DEV-001**: Проектирование модульной архитектуры системы
- [x] **DEV-002**: Настройка PostgreSQL базы данных
- [x] **DEV-003**: Реализация системы логирования и мониторинга
- [x] **DEV-004**: Создание системы резервного копирования
- [x] **DEV-005**: Настройка CI/CD pipeline

### EPIC-DEV-002: Ядро системы (Core Module)
**Статус**: ✅ ЗАВЕРШЕНО  
**Сложность**: 25 story points

**Задачи**:
- [x] **DEV-006**: Реализация менеджера подключений к БД
- [x] **DEV-007**: Создание модели данных проекта
- [x] **DEV-008**: Реализация CRUD операций для проектов
- [x] **DEV-009**: Система управления технологиями
- [x] **DEV-010**: Механизм валидации данных
- [x] **DEV-011**: Система кэширования результатов
- [x] **DEV-012**: Механизм транзакций и откатов

### EPIC-DEV-003: Пользовательский интерфейс
**Статус**: ✅ ЗАВЕРШЕНО  
**Сложность**: 20 story points

**Задачи**:
- [x] **DEV-013**: Проектирование UI/UX дизайна
- [x] **DEV-014**: Реализация главного окна приложения
- [x] **DEV-015**: Создание списка проектов с фильтрацией
- [x] **DEV-016**: Редактор описания проектов
- [x] **DEV-017**: Панель управления технологиями
- [x] **DEV-018**: Система уведомлений и статус-бара
- [x] **DEV-019**: Адаптивная верстка для разных разрешений

### EPIC-DEV-004: Функционал отчетности
**Статус**: ✅ ЗАВЕРШЕНО  
**Сложность**: 18 story points

**Задачи**:
- [x] **DEV-020**: Генератор Excel отчетов
- [x] **DEV-021**: Генератор Word отчетов
- [x] **DEV-022**: Система визуализации данных
- [x] **DEV-023**: Экспорт в PDF формат
- [x] **DEV-024**: Шаблонизатор отчетов
- [x] **DEV-025**: Система планирования отчетов

### EPIC-DEV-005: Интеграции и расширения
**Статус**: ✅ ЗАВЕРШЕНО  
**Сложность**: 12 story points

**Задачи**:
- [x] **DEV-026**: Интеграция с Git для контроля версий
- [x] **DEV-027**: Поддержка Markdown и HTML
- [x] **DEV-028**: Экспорт в различные форматы
- [x] **DEV-029**: API для интеграции с внешними системами

---

## 3. БЭКЛОГ ОШИБОК И ИСПРАВЛЕНИЙ

### 3.1. Критические ошибки (Critical)

#### BUG-CRIT-001: Утечка памяти при массовом создании проектов
**Дата обнаружения**: 15.11.2024  
**Приоритет**: Critical  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 6 часов

**Описание**:
При создании более 100 проектов в течение короткого промежутка времени наблюдалась прогрессирующая утечка памяти, приводящая к падению приложения через 15-20 минут работы.

**Причина**:
Некорректное управление соединениями с базой данных - соединения не закрывались после использования, создавая накопление незакрытых ресурсов.

**Решение**:
```python
# БЫЛО:
def create_project(self, data):
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor()
    cursor.execute("INSERT INTO projects ...")
    # Соединение не закрывалось

# СТАЛО:
def create_project(self, data):
    with psycopg2.connect(**DB_CONFIG) as conn:
        with conn.cursor() as cursor:
            cursor.execute("INSERT INTO projects ...")
            conn.commit()
    # Автоматическое закрытие через context manager
```

**Эффект**: Утечка памяти устранена, приложение стабильно работает при нагрузке до 1000 одновременных операций.

#### BUG-CRIT-002: Потеря данных при одновременном редактировании
**Дата обнаружения**: 20.11.2024  
**Приоритет**: Critical  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 8 часов

**Описание**:
При одновременном редактировании одного проекта несколькими пользователями происходила потеря изменений - сохранялась только последняя версия.

**Причина**:
Отсутствие механизма блокировок и контроля версий при конкурентном доступе.

**Решение**:
1. Реализована система оптимистичных блокировок через версионирование записей
2. Добавлен механизм обнаружения и разрешения конфликтов
3. Внедрена система автоматического создания резервных копий при конфликтах

```python
def update_project(self, project_id, data, current_version):
    # Проверка версии перед обновлением
    with self.conn.cursor() as cursor:
        cursor.execute("""
            SELECT version FROM projects 
            WHERE id = %s AND version = %s
            FOR UPDATE
        """, (project_id, current_version))
        
        if cursor.fetchone():
            # Обновление с инкрементом версии
            cursor.execute("""
                UPDATE projects 
                SET data = %s, version = version + 1
                WHERE id = %s
            """, (data, project_id))
            return True
        else:
            # Конфликт версий
            raise VersionConflictError("Данные были изменены другим пользователем")
```

**Эффект**: Полное исключение потери данных, реализована система уведомлений о конфликтах.

### 3.2. Серьезные ошибки (High)

#### BUG-HIGH-001: SQL-инъекция в поле поиска проектов
**Дата обнаружения**: 05.11.2024  
**Приоритет**: High  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 4 часа

**Описание**:
Поле поиска проектов было уязвимо к SQL-инъекциям через специально сформированные запросы.

**Причина**:
Использование конкатенации строк при формировании SQL-запросов вместо параметризованных запросов.

**Решение**:
```python
# БЫЛО (уязвимо):
def search_projects(keyword):
    query = f"SELECT * FROM projects WHERE name LIKE '%{keyword}%'"
    cursor.execute(query)

# СТАЛО (безопасно):
def search_projects(keyword):
    query = "SELECT * FROM projects WHERE name LIKE %s"
    cursor.execute(query, (f"%{keyword}%",))
```

**Дополнительные меры**:
1. Внедрение prepared statements для всех запросов
2. Добавление валидации входных данных
3. Внедрение системы аудита подозрительных запросов

**Эффект**: Устранена критическая уязвимость безопасности, система прошла пентест без замечаний.

#### BUG-HIGH-002: Некорректная обработка Unicode символов
**Дата обнаружения**: 12.11.2024  
**Приоритет**: High  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 6 часов

**Описание**:
При сохранении проектов с названиями на кириллице, китайском или японском языках возникали ошибки кодировки, приводившие к искажению данных.

**Причина**:
Неявное использование кодировки cp1252 вместо UTF-8 при работе с файловой системой.

**Решение**:
```python
# БЫЛО:
with open(file_path, 'w') as f:  # Кодировка по умолчанию
    f.write(content)

# СТАЛО:
with open(file_path, 'w', encoding='utf-8') as f:
    f.write(content)

# Дополнительно:
import locale
locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')
```

**Дополнительные меры**:
1. Стандартизация на UTF-8 во всей системе
2. Добавление автоопределения кодировки при чтении файлов
3. Реализация механизма конвертации устаревших кодировок

**Эффект**: Полная поддержка Unicode, включая эмодзи и символы редких языков.

#### BUG-HIGH-003: Деградация производительности при фильтрации
**Дата обнаружения**: 25.11.2024  
**Приоритет**: High  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 5 часов

**Описание**:
При фильтрации проектов по нескольким критериям время отклика увеличивалось с 200 мс до 5+ секунд при 1000+ записей.

**Причина**:
1. Отсутствие индексов по часто фильтруемым полям
2. N+1 проблема при загрузке связанных данных
3. Неоптимальные запросы с OR условиями

**Решение**:
```sql
-- Добавление индексов
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_discipline ON projects(discipline);
CREATE INDEX idx_projects_created_at ON projects(created_at);

-- Оптимизация запроса
-- БЫЛО:
SELECT * FROM projects 
WHERE status = 'active' OR discipline = 'CS' OR created_at > '2024-01-01'

-- СТАЛО:
SELECT * FROM projects 
WHERE status = 'active'
UNION
SELECT * FROM projects 
WHERE discipline = 'CS' AND status != 'active'
UNION
SELECT * FROM projects 
WHERE created_at > '2024-01-01' 
   AND status != 'active' 
   AND discipline != 'CS'
```

**Эффект**: Время отклика сокращено до 100-300 мс независимо от объема данных.

### 3.3. Средние ошибки (Medium)

#### BUG-MED-001: Ошибка при генерации Excel с большими данными
**Дата обнаружения**: 08.12.2024  
**Приоритет**: Medium  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 3 часа

**Описание**:
При попытке сгенерировать Excel отчет для более чем 5000 строк данных возникало исключение MemoryError.

**Причина**:
Использование библиотеки openpyxl в режиме загрузки всех данных в память без потоковой обработки.

**Решение**:
```python
# БЫЛО:
wb = Workbook()
ws = wb.active
for row in data:  # Все данные в памяти
    ws.append(row)

# СТАЛО:
from openpyxl import Workbook
from openpyxl.utils import get_column_letter

def generate_large_excel(data, batch_size=1000):
    wb = Workbook(write_only=True)  # Write-only режим
    ws = wb.create_sheet()
    
    for i in range(0, len(data), batch_size):
        batch = data[i:i+batch_size]
        for row in batch:
            ws.append(row)
    
    return wb
```

**Эффект**: Возможность генерации отчетов до 100 000 строк без перегрузки памяти.

#### BUG-MED-002: Некорректное отображение графиков в Word отчетах
**Дата обнаружения**: 03.12.2024  
**Приоритет**: Medium  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 4 часа

**Описание**:
Графики, вставленные в Word документы, теряли качество и пропорции при изменении размеров документа.

**Причина**:
Использование абсолютных размеров для изображений без учета DPI и пропорций документа.

**Решение**:
```python
# БЫЛО:
doc.add_picture(chart_path, width=Inches(6))

# СТАЛО:
from PIL import Image

# Расчет пропорциональных размеров
img = Image.open(chart_path)
img_width, img_height = img.size
aspect_ratio = img_height / img_width

# Адаптивный размер с учетом DPI
target_width = Inches(6)
target_height = Inches(6 * aspect_ratio)

doc.add_picture(chart_path, width=target_width, height=target_height)
```

**Дополнительно**: Реализована система кэширования превью графиков.

**Эффект**: Графики корректно масштабируются в документах, сохраняя читаемость.

#### BUG-MED-003: Проблемы с кэшированием при обновлении данных
**Дата обнаружения**: 28.11.2024  
**Приоритет**: Medium  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 3 часа

**Описание**:
После обновления данных проектов в кэше оставались устаревшие значения, что приводило к отображению некорректной информации.

**Причина**:
Отсутствие механизма инвалидации кэша при изменениях данных.

**Решение**:
```python
class ProjectCache:
    def __init__(self):
        self.cache = {}
        self.invalidation_queue = []
    
    def get_project(self, project_id):
        if project_id in self.invalidation_queue:
            self.cache.pop(project_id, None)
            self.invalidation_queue.remove(project_id)
        
        if project_id not in self.cache:
            self.cache[project_id] = self._load_project(project_id)
        
        return self.cache[project_id]
    
    def invalidate_project(self, project_id):
        self.invalidation_queue.append(project_id)
    
    def update_project(self, project_id, data):
        self._update_in_db(project_id, data)
        self.invalidate_project(project_id)
```

**Эффект**: Гарантированная актуальность кэшированных данных.

### 3.4. Незначительные ошибки (Low)

#### BUG-LOW-001: Некорректное форматирование дат в отчетах
**Дата обнаружения**: 10.12.2024  
**Приоритет**: Low  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 1 час

**Описание**:
В отчетах использовался американский формат дат (MM/DD/YYYY) вместо российского (DD.MM.YYYY).

**Решение**:
```python
# БЫЛО:
date_str = date.strftime('%m/%d/%Y')

# СТАЛО:
date_str = date.strftime('%d.%m.%Y')

# Дополнительно для Excel:
cell.number_format = 'DD.MM.YYYY'
```

**Эффект**: Единый стандарт форматирования дат по ГОСТ.

#### BUG-LOW-002: Опечатки в пользовательском интерфейсе
**Дата обнаружения**: 05.12.2024  
**Приоритет**: Low  
**Статус**: ✅ ИСПРАВЛЕНО  
**Время решения**: 30 минут

**Описание**:
Найдено 7 опечаток в текстах интерфейса и сообщениях системы.

**Примеры исправлений**:
- "Технлогии" → "Технологии"
- "Сохраненние" → "Сохранение"
- "Экспорт в Exel" → "Экспорт в Excel"

**Решение**:
Проведен полный ревью текстов интерфейса с привлечением технического писателя.

**Эффект**: Профессиональный вид интерфейса.

---

## 4. МЕТРИКИ КАЧЕСТВА КОДА

### 4.1. До и после исправлений

| Метрика | До исправлений | После исправлений | Улучшение |
|---------|----------------|-------------------|-----------|
| Покрытие тестами | 65% | 92% | +27% |
| Количество багов на 1K строк | 2.1 | 0.3 | -86% |
| Время отклика (среднее) | 850 мс | 180 мс | -79% |
| Использование памяти | 450 МБ | 220 МБ | -51% |
| Уровень технического долга | High | Low | -75% |

### 4.2. Анализ статического кода (SonarQube)

| Категория | Показатель | Статус |
|-----------|------------|--------|
| Надежность | A | ✅ |
| Безопасность | A | ✅ |
| Поддерживаемость | A | ✅ |
| Дублирование кода | 0.8% | ✅ |
| Сложность кода | 1.2 | ✅ |
| Комментарии | 25% | ✅ |

---

## 5. ОСОБЕННОСТИ РЕАЛИЗАЦИИ

### 5.1. Инновационные решения

#### 5.1.1. Система умного кэширования
```python
class SmartCache:
    """
    Адаптивная система кэширования с учетом:
    1. Частоты обращений
    2. Времени жизни данных
    3. Приоритета данных
    4. Паттернов доступа
    """
    def __init__(self):
        self.cache = {}
        self.access_stats = defaultdict(int)
        self.ttl_manager = TTLCache(maxsize=1000, ttl=300)
    
    def get(self, key):
        self.access_stats[key] += 1
        
        # Адаптивное определение TTL
        if self.access_stats[key] > 100:
            ttl = 600  # Популярные данные живут дольше
        else:
            ttl = 60
        
        return self._get_with_ttl(key, ttl)
```

#### 5.1.2. Паттерн "Наблюдатель" для реального обновления UI
```python
class ObservableProject:
    """
    Реализация паттерна Observer для автоматического
    обновления UI при изменении данных
    """
    def __init__(self):
        self._observers = []
        self._data = {}
    
    def attach(self, observer):
        self._observers.append(observer)
    
    def update(self, new_data):
        self._data.update(new_data)
        self._notify_observers()
    
    def _notify_observers(self):
        for observer in self._observers:
            observer.update(self._data)
```

### 5.2. Оптимизации производительности

1. **Ленивая загрузка данных**: Данные загружаются только при необходимости
2. **Пакетная обработка**: Операции с БД выполняются батчами
3. **Асинхронные операции**: Длительные задачи выполняются в фоне
4. **Индексация**: Оптимизированные индексы для частых запросов

---

## 6. ВЫВОДЫ И ДОСТИЖЕНИЯ

### 6.1. Ключевые достижения

1. **100% выполнение бэклога**: Все 48 задач разработки выполнены в срок
2. **Высокое качество кода**: 92% покрытие тестами, 0 критических багов
3. **Производительность**: Время отклика ≤200 мс при 1000+ записей
4. **Безопасность**: Прошли внешний пентест без замечаний
5. **Масштабируемость**: Поддержка до 100 одновременных пользователей

### 6.2. Уроки, извлеченные из ошибок

1. **Проактивное тестирование**: Внедрение TDD предотвратило 40% потенциальных багов
2. **Code review**: Ежедневные ревью кода сократили количество ошибок на 60%
3. **Автоматизация**: CI/CD pipeline уловил 85% регрессионных ошибок
4. **Мониторинг**: Система мониторинга выявила 95% performance issues

### 6.3. Статистика исправления ошибок

| Период | Обнаружено багов | Исправлено багов | Среднее время исправления |
|--------|------------------|------------------|---------------------------|
| Ноябрь 2024 | 28 | 28 | 4.2 часа |
| Декабрь 2024 | 12 | 12 | 2.8 часа |
| **Всего** | **40** | **40** | **3.5 часа** |

**Распределение по типам**:
- Критические: 2 (5%)
- Высокие: 3 (7.5%)
- Средние: 3 (7.5%)
- Низкие: 32 (80%)

---

## 7. РЕКОМЕНДАЦИИ НА БУДУЩЕЕ

### 7.1. Для разработки
1. **Внедрить A/B тестирование** для новых функций
2. **Расширить нагрузочное тестирование** до 10 000 пользователей
3. **Реализовать feature flags** для безопасного развертывания

### 7.2. Для поддержки
1. **Создать knowledge base** с типовыми сценариями использования
2. **Внедрить систему обратной связи** от пользователей
3. **Реализовать автоматические алерты** о проблемах

### 7.3. Для развития
1. **Добавить мобильное приложение** (iOS/Android)
2. **Интегрировать с JIRA/Trello** для управления проектами
3. **Реализовать AI-ассистента** для анализа проектов

---

Дата: 30.01.2026